# 合理利用‘冗余’空间

------

在工作时经常会发现这样的情况：通过记录更多的信息往往可以让代码性能得到明显提升。这种情况应用场景很多，比如基于键索引计数法的字符串排序法：

```
  function sort(a, w) {
    let N = a.length;
    let R = 256;
    let aux = [];

    for (let d = w - 1; d >= 0; d--) {
      let count = new Array(R + 1).fill(0);
      for (let i = 0; i < N; i++) {
        count[a[i].charCodeAt(d) + 1]++;
      }
      for (let i = 0; i < R; i++) {
        count[i + 1] += count[i];
      }
      for (let i = 0; i < N; i++) {
        aux[count[a[i].charCodeAt(d)]++] = a[i];
      }
    }
    return aux;
  }
```

这是一种不需要比较的方法排序，方法时间复杂度为O(n)，而一般(需要比较的)排序方法理论时间复杂度极限为O(nlgn)，之所以突破这个理论极限是因为依赖了了系统内置的ASCII字符表（R=256）所提供的‘顺序信息’，而通过定义自己字符集或是使用哈希表（其实字符集本身就是一种哈希表）还可以扩大这种排序方法的适用范围。
另一个例子，left-pad包中找到的如下代码：

```
  var cache = [
    '',
    ' ',
    '  ',
    '   ',
    '    ',
    '     ',
    '      ',
    '       ',
    '        ',
    '         '
  ];

  function leftPad (str, len, ch) {
    // ...
    if (ch === ' ' && len < 10) return cache[len] + str;
    // ...
  }
```
作者将最常用的用例' '和最长用的长度范围‘16以内’缓存起来，可以提升大部分情况下的运行效率，时间复杂度由O(log(n))降低为常数时间。

由以上例子可以看到在合理的情况下牺牲一些空间是很有必要，而在另一些情况下牺牲一些空间不仅能够提高代码的运行效率还能够降低模块间的耦合，提升代码的可维护性。我再工作中有如下场景，系统中有一批传感器会上行各自的传感数据，在此对其进行数据建模 Device，在‘数据处理’模块进行数据解析、保存，而系统中还有在这些数据之上运行的业务——数据报警：用户可以自定义一个阈值，超过这个阈值便会触发报警，发送邮件、短信、socket推送等。数据报警需要一个另一个模块维护——‘报警分析’，在此对这些报警消息进行数据建模 Alarm，一个设备的数据上行数据是连续的，而为了用户体验不能连续报警，所以业务逻辑设定为一个设备处于报警状态则只发送一次报警消息。一般的处理流程是‘数据处理’模块对数据进行处理存储然后将数据推送给‘报警分析’模块，由该模块判断该设备 是否已经触发了用户的设置阈值 和 是否已经发送过至少一次警报，然后决定是否报警。看起来没有什么问题，但是设备数量增长上来以后，并发数陡增，这时‘报警分析’在判断‘是否至少发送过一次报警’时候的对 Alarm 的一次数据库查询就变得十分昂贵了，这时可以考虑数据处理模块负责一部分‘报警分析’的逻辑，在数据处理的同时也判断是否触发了预警并将对应的传感器状态存储于 Device 中（冗余记录数据），则可以减少这次数据库查询，在任何服务中减少一次数据库查询带来的性能提升都是很明显的。实际情况要复杂些，一个设备可能有多种传感器，但是逻辑同样适用。这里牺牲了一部分数据库空间使服务性能得到了提升，道理说出来就简单了，但是往往由于逻辑分散在各个文件内使开发者意识不到这一点。