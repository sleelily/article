# λ演算

### λ演算是什么？

λ演算不是一种思想也不是一种定律，只是一种简洁高效且精确定义的函数规则。例如中学课本中我们会学到数学中的函数: f(x) = x² - 2x + 1，我们清楚f(x)是关于x的函数，但是只从这个等式中我们无法确定函数的具体定义，它可以是 f(x) = x^x - 2x + 1，也可以是 g(x) = (x-1)²，所以当参数改变时无法真正确定所得值。λ演算引入了更清晰的定义，在该定义中函数只允许单个参数的传入，λx.x² - 2x + 1 只能表示x² - 2x + 1，因为x-1并非单一参数。
通常我们将可以表示运算规则的函数叫做λ表达式，它有如下定义:

> 1. 一个变量 x 就是一个合法的λ表达式。
  2. 如果 t 是一个合法的λ表达式，x是一个普通变量，那么 λx. t 也是一个合法的λ表达式。
  3. 如果 t 和 s 都是一个合法的λ表达式，那么 t s 也是一个合法的λ表达式。

这三条规则代表了三种含义，第一条表示变量，通过它我们可以知道形如：

```javascript
    x
    y
```

都是合法的λ表达式，这是λ表达式的基础。现在我们可以利用第一条中所知道的合法表达式，创建出如下合法表达式：

```javascript
    λx. x
    λx. y
    λy. x
    λy. y
```

他们表示λ抽象也就是我们通常意义上的函数定义， λx. x 中 第一个x表示参数定义，第二个代表函数返回值，如果你使用过Javascript中的箭头函数，一定对此类定义不陌生：`(x) => x`, 它和 `λx. x` 是等价的，表示输出与输入相同，叫做恒等函数，而 `(x) => y` 与 `λx. y` 是等价的，表示输出恒等与输入无关，叫做恒等函数，这是λ演算中很重要的定义，细心的你还会发现 `λx. x` 和 `λy. y` 也是等价的(`λx. y` 和 `λy. x` 不是, 因为y和x是外部变量，也叫做自由变量，对应 `λx. x` 中的 x 叫做约束变量)，我们可以更改参数的名字来做到，这在λ演算叫做`α转换`。再结合第三条我们可以创建出所有的λ形式:

```javascript
    x x
    x y
    (λx. x) y
    (λy. y) x
    (λx. x) (λx. x)
    (λy. y) (λx. x)
```

它表示函数应用，是λ表达式间的相互应用，期间会发生函数执行如`(λx. x) y`表示以 y 为参数执行 `λx. x` 函数，写过无数函数的我们知道结果为 y，过程如下:

```javascript
    (λx. x) y
    x [x := y]
    y
```

x参数被s赋值，更复杂的调用如:

```javascript
    (λy.(λx. x) y) a b
    ((λx. x) y) [y := a]) b
    (λx. x) a b
    (x [x := a]) b
    a b
```

其遵循的规则是一样的，其中函数的调用及参数的赋值应用叫做β迭代，我们可以看到λ用了很简单的单参函数就可以表示很复杂的运算，利用这些规则我们可以发现很多有意思的事。

### 各种要素的λ定义

#### 1. 多参函数的定义
lambda表达式可以定义编程中的所有要素，函数、数据甚至是数据类型。上面我们已经了解到所有lambda表达式都是单参函数，而多参函数经过柯里化后可以得到等价的单参函数：

```javascript
    (x, y) => { return xy }
    // 等价于
    (x) => (y) => { return xy }
```

#### 2. 布尔值的定义
lambda表达式虽然是函数的形式，但是它也可以表示数据，只要我们的思维转化一下，例如，布尔值的lambda表达式形式如下：

```javascript
    // true
    var TRUE = λx.λy.x
    // false
    var FALSE = λx.λy.y
```

因为布尔值是一个二元数据类型，所以我们也可以使用一个二元操作集合来表示它：固定返回两个参数中的一个。这个简单的定义可以帮助我们实现很多东西，比如`if(...)else(...)`语句：

```javascript
    // 一般的if else语句定义
    if (x) {
        y
    } else {
        z
    }
    // 等价于: 
    // 若x为true
    (((λx.λy.x)y)z) === (λy.λz.y) === y
    // 若x为false
    (((λx.λy.y)y)z) === (λy.λz.z) === z
```

可以看到上面通过函数定义的数据，参与了控制代码的执行，从而能够轻松进行数据与代码的转换，而有了`if(...)else(...)`语句，其他的逻辑语句也可以有其各自的lambda定义：

```javascript

    var IF = λc.λe1.λe2.((c e1) e2);

    var AND = λx.λy.(((IF x) y) FALSE) === λx.λy.((x y) FALSE) === λx.λy.xyy;
    var OR = λx.λy.(((IF x) TRUE) y) === λx.λy.((x TRUE) y) === λx.λy.xxy;
    var NOT = λx.(((IF x) FALSE) TRUE) === λx.λy.((x FALSE) TRUE) === λx.λy.xyx;
```

有些过于抽象，但只要记住一点，数据现在都是控制代码的一部分就很好理解了，如 `λx.λy.xxy` 表示以布尔值代码执行x如果为真则执行x语句，否则执行y语句。

#### 3. 自然数的定义

是的，lambda表达式也可以表示自然数，代价也是只需要我们转换一下思维，什么是自然数呢？纯数学上的定义是1、2、3...这种，具体应用在实际中可能是团队中的人数、代码的行数，也可以是睡觉时数的绵羊次数，注意我们提到了‘次数’，lambda中我们将自然数具象为函数执行次数：

```javascript
    0 = λf.λx.x
    1 = λf.λx.fx
    2 = λf.λx.f(fx)
    3 = λf.λx.f(f(fx))
```

可以看到数字几就代表函数f对第二个参数x执行了几次，通过这种形式的自然数，我们可以得到算术相关的操作定义（实际上是两个自然数间的转换关系），我们可以先定义一个`后继函数`：

```javascript
    n = λf.λx.f(n-1) = λf.λx.f(...(f(f(fx)))...) = λf.λx.fnx
```


